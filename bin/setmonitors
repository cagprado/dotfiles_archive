#!/usr/bin/env python3

import subprocess
from os import listdir, environ
from os.path import isfile, basename
from binascii import b2a_base64
from argparse import ArgumentParser

syspath = "/sys/class/drm/"


def main():
    args = parse_arguments()
    monitors = get_monitors()

    if args.i:
        print_monitors(monitors)
    else:
        setup_monitors(monitors, args)
        subprocess.run([environ['HOME'] + '/.fehbg'])


# known monitors EDID (base64) vs DPI
dpi_table = {
    "AP///////wAoiSpCAAAAAAAbAQSlHRR4A95Qo1RMmSYPUFQAAAABAQEBAQEBAQEBAQEBAQEBt"
    "5i4oLDQPnAIIAgMJcQQAAAat5i4oLDQQXIIIAgMJcQQAAAaAAAA/gBKREkgICAgICAgICAgAA"
    "AA/gBMUE0xMzlNNDIyQSAgADk=": 205.0,   # MateBook Pro X
    "AP///////wAJ5dsHAAAAAAEcAQSlHxF4An1QpldSnycSUFQAAAABAQEBAQEBAQEBAQEBAQEBO"
    "jiA3nA4KEAwIDYANa4QAAAa+yyA3nA4KEAwIDYANa4QAAAaAAAA/gBCT0UgQ1EKICAgICAgAA"
    "AA/gBORTE0MEZITS1ONjEKAEM=": 124.0,   # X1 Carbon
    "AP///////wBNEEkUAAAAACAZAQSlHRF4Dt5Qo1RMmSYPUFQAAAABAQEBAQEBAQEBAQEBAQEBG"
    "jaAoHA4H0AwIDUAJqUQAAAYAAAAEAAAAAAAAAAAAAAAAAAAAAAA/gBESkNQNoBMUTEzM00xAA"
    "AAAAACQQMoABIAAAsBCiAgAGY=": 132.5,  # XPS13
    "AP///////wAQrKxBWTk4NREdAQOAPCJ47u6Vo1RMmSYPUFSlSwBxT4GAqUDRwAEBAQEBAQEBV"
    "l4AoKCgKVAwIDUAVVAhAAAaAAAA/wBHM0NHTVMyCiAgICAgAAAA/ABERUxMIFUyNzE5RFMKAA"
    "AA/QA4TB5aGQAKICAgICAgAakCAyLxT5AFBAMCBxYBBhESFRMUHyMJfweDAQAAZQMMABAAAjq"
    "AGHE4LUBYLEUAVVAhAAAefjkAoIA4H0AwIDoAVVAhAAAaAR0AclHQHiBuKFUAVVAhAAAevxYA"
    "oIA4E0AwIDoAVVAhAAAaAAAAAAAAAAAAAAAAAAAAAAAAAAAAiA==": 109  # Dell U2719D
}


def error(msg):
    print("{}: error: {}".format(basename(__file__), msg))
    exit(1)


def parse_arguments():
    # parse commandline
    parser = ArgumentParser(description='''Sets resolution and position of
                            multiple monitors using xrandr. If run without
                            arguments, performs the same as '-l'.''')
    group = parser.add_mutually_exclusive_group()
    group.add_argument('-i', action='store_true', help='''list available
                       monitor configuration and exit''')
    group.add_argument('-l', action='store_true', help='''auto mode: sets
                       laptop screen (eDP) as primary and position all other
                       monitors to the left''')  # ignored: default behaviour
    group.add_argument('-r', action='store_true', help='''auto mode: sets
                       laptop screen (eDP) as primary and position all other
                       monitors to the right''')
    group.add_argument('-s', action='store_true', help='''only one external
                       monitor is set''')
    group.add_argument('-S', action='store_true', help='''only laptop internal
                       monitor (eDP) is set''')
    group.add_argument('-m', metavar=('M1', 'M2'), type=str, nargs='+',
                       help='''setup monitors manually; list monitors by name
                       from left to right.  Append options to monitor names,
                       separated by ':', ex: 'eDP-1:lp'. Available options
                       (l)eft rotation, (r)ight rotation, (i)nverted rotation,
                       (p)rimary''')
    return parser.parse_args()


def get_monitors():
    # get available devices from syspath
    devices = [i for i in listdir(syspath) if isfile(syspath + i + "/status")]
    devices.sort()

    # get available monitors from xrandr
    xrandr = subprocess.run(['xrandr'], capture_output=True, text=True).stdout
    names = [l.split()[0] for l in xrandr.split('\n') if "connected" in l]
    names.sort()

    # remove blacklisted output (virtual and such)
    blacklist = ['VIRTUAL']
    blacklist = [any(pat in name for pat in blacklist) for name in names]
    names = [x for (x, rm) in zip(names, blacklist) if not rm]

    return [Monitor(a, b) for a, b in zip(names, devices)]


def print_monitors(monitors):
    for monitor in monitors:
        print(monitor)


def setup_monitors(monitors, args):
    priority = build_priority([i.name for i in monitors if i.connected], args)

    # order monitors on priority list
    monitors = sorted(monitors, key=lambda monitor: monitor.priority(priority))

    # set scale of non-hidpi monitors if one hidpi is available
    if any(monitor.hidpi for monitor in monitors):
        for monitor in monitors:
            if not monitor.hidpi:
                monitor.scale = [2, 2]

    # set position of monitors
    position = 0
    for monitor in monitors:
        if monitor.connected:
            monitor.position = [position, 0]
            if monitor.horizontal:
                position += monitor.scale[0] * monitor.mode[0]
            else:
                position += monitor.scale[1] * monitor.mode[1]

    # generate command line for xrandr
    command_args = ['xrandr', '--dpi',
                    str(max([i.dpi for i in monitors if i.connected]))]
    for monitor in monitors:
        command_args += monitor.xrandr.split()

    print(command_args[2])
    subprocess.run(command_args)


def build_priority(connected, args):
    if args.m:
        # manually given priority list: just check validity
        for name in args.m:
            name, _, options = name.partition(':')
            if name not in connected:
                error("argument -m: invalid monitor name '{}'".format(name))
            if not set(options) <= set('lrip'):
                error("argument -m: invalid options used '{}'".format(options))
        return args.m

    # no list given, build one automatically from all connected monitors
    for i, name in enumerate(connected):
        # set eDP monitor (laptop internal) first in the list
        if "eDP" in name:
            connected.insert(0, connected.pop(i))

    if args.s:
        # turn on only one monitor (preferably external)
        connected = connected[-1:]
    elif args.S:
        # turn on only one monitor (preferably internal)
        connected = connected[:1]

    # set the primary monitor
    connected[0] += ':p'

    # order position alternating left and right
    connected = [x for _, x in sorted(zip(
        [i % 2 and -i or i for i, _ in enumerate(connected)], connected))]

    # reverse order if '-r' is given
    if args.r:
        connected.reverse()

    return connected


def readfile(filename):
    """Reads a file and returns its contents as string"""
    if filename.endswith('edid'):
        # we need to read binary data for this file
        with open(filename, 'rb') as file:
            return b2a_base64(file.read()).decode('ascii').strip()
    else:
        with open(filename, 'r') as file:
            return file.readline().strip()


class Monitor:
    """Describes the properties of monitors available to the system"""

    def __init__(self, name, dev):
        """Initializes the basic properties of a Monitor"""
        self.name = name
        self.connected = ('connected' == readfile(syspath + dev + "/status"))

        if self.connected:
            self.position = [0, 0]
            self.primary = False
            self.scale = [1, 1]
            self.rotation = 'normal'

            mode = readfile(syspath + dev + "/modes")
            self.mode = [int(x) for x in mode.split('x')]

            edid = readfile(syspath + dev + "/edid")
            self.dpi = edid in dpi_table and dpi_table[edid] or 96.0

    @property
    def hidpi(self):
        return self.connected and self.dpi > 150

    @property
    def horizontal(self):
        return self.rotation == 'normal' or self.rotation == 'inverted'

    @property
    def vertical(self):
        return not self.horizontal

    @property
    def xrandr(self):
        if not self.connected:
            return "--output {} --off".format(self.name)

        else:
            out = "--output {}".format(self.name)
            out += " --mode {}x{}".format(self.mode[0], self.mode[1])
            out += " --scale {}x{}".format(self.scale[0], self.scale[1])
            out += " --pos {}x{}".format(self.position[0], self.position[1])
            out += " --rotate {}".format(self.rotation)
            if self.primary:
                out += " --primary"
            return out

    def __str__(self):
        """Returns the string representation of a Monitor object"""
        output = self.name + ":\n - Connected:\t"
        if self.connected:
            output += "Yes\n" \
                " - Primary:    \t{}\n" \
                " - DPI:        \t{} {}\n" \
                " - Mode:       \t{}x{}\n" \
                " - Scale:      \t{}x{}\n" \
                " - Position:   \t{}x{}\n" \
                " - Rotation:   \t{}\n" \
                .format(self.primary, self.dpi, self.hidpi and "(HiDPI)" or "",
                        self.mode[0], self.mode[1], self.scale[0],
                        self.scale[1], self.position[0], self.position[1],
                        self.rotation)
        else:
            output += "No\n"
        return output

    def priority(self, priority):
        i = [priority.index(x) for x in priority if x.startswith(self.name)]

        if not i:
            self.connected = False
            return len(priority)

        if len(i) > 1:
            error("monitor '{}' specified more than once".format(self.name))

        options = priority[i[0]].partition(':')[2]
        if 'p' in options:
            self.primary = True
        if 'i' in options:
            self.rotation = 'inverted'
        elif 'l' in options:
            self.rotation = 'left'
        elif 'r' in options:
            self.rotation = 'right'

        return i[0]


if __name__ == "__main__":
    main()
